package java_enum;

import java.io.Serializable;
import java.util.EnumMap;
import java.util.EnumSet;

import static java_enum.EnumValue.Money.DIME;
import static java_enum.EnumValue.Money.PENNY;


class DoubleCheckedLockingSingleton {
    static private volatile DoubleCheckedLockingSingleton INSTANCE;

    private DoubleCheckedLockingSingleton() {
    }

    static public DoubleCheckedLockingSingleton getInstance() {
        if (INSTANCE == null) {
            synchronized (DoubleCheckedLockingSingleton.class) {
                if (INSTANCE == null) {
                    INSTANCE = new DoubleCheckedLockingSingleton();
                }
            }
        }
        return INSTANCE;
    }
}

class Singleton {
    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {
    }

    // static factory method
    public static Singleton getSingleton() {
        return INSTANCE;
    }
}

/**
 * Enum Singleton handles lot of stuff for you e.g.
 * controlled instance creation,
 * Serialization safety
 * thread-safe, You don’t need to worry about double checked locking and volatile variable anymore.
 */
enum EasySingleton implements Serializable {
    INSTANCE;
    // once you implement serializable interface they are no longer remain Singleton
    // because readObject() method always return a new instance just like constructor in Java.
    // you can avoid that by using readResolve() method and discarding newly created instance
    // by replacing with Singeton as shwon in below example, witn Enum Singleton, Serialization is guarnateed by JVM.

    //readResolve to prevent another instance of Singleton
    private Object readResolve() {
        return INSTANCE;
    }
}

interface Strategy {

    int execute(int a, int b);
}

enum Math implements Strategy {

    Add {
        @Override
        public int execute(int a, int b) {
            return a + b;
        }
    },
    Subtract {
        @Override
        public int execute(int a, int b) {
            return a - b;
        }
    },
    Multiply {
        @Override
        public int execute(int a, int b) {
            return a * b;
        }
    };
}

public class EnumValue {
    /**
     * <pre>
     * An instance of Enum in Java is created when any Enum constants are first called or referenced in code.
     * Enum in Java can implement the interface and override any method like normal class
     * It’s also worth noting that Enum in java implicitly implements both Serializable and Comparable interface.
     *
     * enum class can not extend class in Java.
     * all Enum by default extend abstract base class java.lang.Enum,
     * obviously they can not extend another class,  Because of extending java.lang.Enum class,
     * all enum gets methods like ordinal(), values() or valueOf().
     * Enum doesn't have any public constructor.
     * the only constructor of creating enum, which is called by code, generated by compiler in response to
     * enum type declaration in Java program. compiler generates lot of code in response to
     * enum type declaration, it doesn’t allow public constructors inside Enum,
     * which enforces declaring enum instances inside Enum itself. you Can declare Constructor inside Enum, but
     * you can only declare either private or package-private constructor inside enum.
     * public and protected constructors are not permitted inside enum.
     * Enum implements Comparable interface. so you can use enum class in Sorted Collection TreeSet or TreeMap
     * Enum constraints are compared in the order they are declared. enum constants are only comparable to other enum constants of the same enum type.
     *
     * see {@link java.lang.Enum#Enum(String, int)}
     */
    enum Money implements Runnable {
        // final you can safely compare them using "==",
        PENNY(1) {
            @Override
            public String color() {
                return "copper";
            }
        }, NICKLE(5) {
            @Override
            public String color() {
                return "bronze";
            }
        }, DIME(10) {
            @Override
            public String color() {
                return "silver";
            }
        }, QUARTER(25) {
            @Override
            public String color() {
                return "silver";
            }
        };

        int v;

        //constructors are implicitly static and final
        //can only be private and Enums constants can only be created inside Enums itself.
        Money(int v) {
            this.v = v;
        }

        int myValue() {
            return v;
        }

        @Override // can over ride
        public String toString() {
            // Enum instances are compile time constant, you can safely use them inside switch and case statements.
            switch (this) {
                case PENNY:
                    System.out.println("Penny: " + v);
                    break;
                case NICKLE:
                    System.out.println("Nickle: " + v);
                    break;
                case DIME:
                    System.out.println("Dime: " + v);
                    break;
                case QUARTER:
                    System.out.println("Quarter: " + v);
            }
            return super.toString();
        }

        @Override
        public void run() {
            System.out.println("implement Runnable interfaces");
        }

        //can define abstract methods inside Enum in Java and can also provide a different
        // implementation for different instances of enum  .
        public abstract String color();
    }

    //you can create Enum without any instance in Java
    enum MessageUtil {
        ;  // required to avoid compiler error, also signifies no instance

        public static boolean isValid() {
            throw new UnsupportedOperationException("Not supported yet.");
        }

    }

    public static void main(String[] args) {
        System.out.println(Money.QUARTER.ordinal());
        System.out.println(Money.QUARTER.myValue());

        // Enum in java can be used as an argument on switch statement and with "case"
        Money m = Money.valueOf("DIME");
        switch (m) {
            case PENNY:
                System.out.println(PENNY.toString());
                break;
            case DIME:
                System.out.println(DIME.toString());
                break;
        }

        EnumMap map = new EnumMap(Money.class);
        map.put(DIME, 1);


        // EnumSet doesn't have any public constructor instead it provides
        // factory methods to create instance e.g. EnumSet.of() methods.
        // This design allows EnumSet to internally choose between two different implementations
        // depending upon the size of Enum constants.
        // This arrangement is also very extensible and manageable because you can
        // introduce new EnumSet implementation without breaking client code.

         //  RegularEnumSet uses long variable, which is a 64 bit data type,
        // it can only hold that much of element. That's why when an empty EnumSet is created
        // using EnumSet.noneOf() method, it choose RegularEnumSet if key universe
        // (number of enum instances in Key Enum) is less than or equal to 64 and
        // JumboEnumSet if key universe is more than 64.

        EnumSet set = EnumSet.noneOf(Money.class);
    }
}
